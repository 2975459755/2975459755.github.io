---
title: 408DS
date: 2025-05-22 17:33:00 +0800
categories: [408Notes]
tags: 

comments: true
math: true
mermaid: true
toc: true

pin: true
---

## 线性表

#### 线性表的定义

- 有限个数
- 线性：元素一对一的相邻关系
- 逻辑上的顺序性：元素有先后顺序

> 线性表的位置次序从1开始
{: .prompt-warning}

```cpp
InitList(&L);			//初始化
Length(L);				//求表长
LocateElem(L, e); 		//按值查找
GetElem(L, i);			//按位查找
ListInsert(&L, i, e);	//在第i位插入值为e的元素
ListDelete(&L, i, &e);	//删除第i位，用e返回元素值
PrintList(L);			//输出
Empty(L);				//判空
DestroyList(&L);		//销毁
```

### 顺序表

#### 定义

用地址连续的存储单元依次存储元素

静态分配
```cpp
#define MaxSize 50

typedef struct {
	ElemType data{MaxSize};
	int length;
} SqList;

void InitList(SqList &L) {
	L.length = 0;
}
```

动态分配
```cpp
#define InitSize 100

typedef struct {
	ElemType *data;
	int MaxSize, length;
} SqList;

void InitList(SqList &L) {
	L.data = (ElemType*) malloc(InitSize * sizeof(ElemType));
	L.length = 0;
	L.MaxSize = InitSize;
}
```

动态分配语句
```cpp
	L.data = (ElemType*) malloc(sizeof(ElemType) * InitSize); // in C
	L.data = new ElemType[InitSize]; // in Cpp
```

#### 特性

- 逻辑顺序与存储的物理顺序相同
- 存储密度高
- 支持随机访问（直接访问）
- 插入和删除麻烦 (O(n))

#### 插入

在顺序表的第 `i` $(1 <= i <= L.length + 1)$ 个位置插入 `e`
```cpp
bool ListInsert(SqList &L, int i, ElemType e) {
	if (i < 1 or i > L.length + 1) 	
		return false;
	if (L.length >= MaxSize) 
		return false;

	for (int j = L.length; j > i - 1; j --) {
		L.data[j] = L.data[j - 1];
	}
	L.data[i - 1] = e;

	L.length ++;

	return true;
}
```

> 时间复杂度： $O(n)$ 
{: .prompt-info}

#### 删除

删除第`i`个位置元素$(1 <= i <= L.length)$，将其值`e`带回
```cpp
bool ListDelete(SqList &L, int i, ElemType &e) {
	if (i < 1 or i > L.length) 
		return false;

	e = L.data[i - 1];
	for (int j = i; j < L.length; j ++) 
		L.data[j - 1] = L.data[j];

	L.length --;

	return true;
}
```

> 时间复杂度： $O(n)$ 
{: .prompt-info}

#### 查找

```cpp
int LocateElem(SqList L, ElemType e) {
	int i;
	for(int i = 0; i < L.length; i ++) {
		if (L.data[i] == e) 
			return i + 1;
	}

	return -1;
}
```

> 按值查找时间复杂度： $O(n)$ \
按序号查找时间复杂度： $O(1)$ 
{: .prompt-info}

### 单链表

#### 定义

```cpp
typedef struct LNode {
	ElemType data;
	struct LNode *next;
} LNode, *LinkList;

bool InitList(LinkList &L) {
	L = (LNode*) malloc(sizeof(LNode));
	L -> next = NULL;
	return true;
}
```

头节点的优点：
- 统一第一个位置和其余位置的操作
- 统一空表和非空表的操作

#### 查找

```cpp
/* 按序号查找 */
Lnode* GetElem(LinkList L, int i) {
	LNode *p = L;
	int index = 0;
	while (p != NULL and index < i) {
		p = p -> next;
		index ++;
	}

	return p;
}

/* 按值查找 */
LNode* LocateElem(LinkList L, ElemType e) {
	LNode *p = L -> next;
	while (p != NULL and p -> data != e)
		p = p -> next;

	return p;
}
```

如果没有找到，会返回`null`

> 按序号查找时间复杂度： $O(n)$ \
按值查找时间复杂度： $O(n)$ 
{: .prompt-info}

#### 插入

先找到第i-1个结点
```cpp
bool ListInsert(LinkList &L, int i, ElemType e) {
	LNode *p = GetElem(L, i - 1);
	if (p == NULL)
		return false;

	LNode *s = (LNode *) malloc(sizeof(LNode));
	s -> data = e;				// 1
	s -> next = p -> next;		// 2
	p -> next = s;

	return true;
}
```

不带头结点时，插入第一个位置时需要特殊处理

> 插入时间复杂度： $O(n)$
{: .prompt-info}

对给定结点`*p`进行前插操作：
可以通过找到其前结点，进行后插操作，其时间复杂度与后插相同，为$O(n)$；
也可以交换`*p`和待插入结点的值，然后把待插入结点插入`*p`后，时间复杂度为$O(1)$

#### 删除

需要判断边界
```cpp
bool ListDelete(LinkList &L, int i, ElemType &e) {
	LNode *p = GetElem(L, i - 1);
	if (p == NULL or p -> next == NULL)
		return false; 

	LNode *q = p -> next;
	e = q -> data;
	p -> next = q -> next;
	free(q);

	return true;
}
```

> 删除复杂度： $O(n)$
{: .prompt-info}

对给定结点`p`进行删除操作：
可以通过找到其前结点，进行删除操作，时间复杂度为$O(n)$；
也可以复制后结点的值到`p`，然后删除后结点，时间复杂度为$O(1)$

#### 建立单链表

头插法：将新元素放在头结点之后；
尾插法：需要有一个尾结点`r`，将新元素放在尾结点`r`之后；
```cpp
/* 头插法 */
LinkList List_HeadInsert(LinkList &L) {
	LNode *L;
	InitList(L);

	LNode *s;
	ElemType x;
	while (cin >> x) {
		s = (LNode *) malloc(sizeof(LNode));
		s -> data = x;
		s -> next = L -> next;
		L -> next = s;
	}

	return L;
}

/* 尾插法 */
LinkList List_TailInsert(LinkList &L) {
	LNode *r, *s;
	InitList(r);

	ElemType x;
	while (cin >> x) {
		s = (LNode *) malloc(sizeof(LNode));
		s -> data = x;
		r -> next = s;
		r = s;
	}
	r -> next = NULL;

	return r;
}
```

### 双链表

#### 定义

```cpp
typedef	struct DNode {
	ElemType data;
	struct DNode *piror, *next;
} DNode, *DLinkList;
```

#### 插入，删除

```cpp
/* 将*s插入p后 */
	s -> next = p -> next;
	p -> next -> prior = s;
	s -> prior = p;
	p -> next = s;			//必须在第一步之后

/* 删除q */
	p -> next = q -> next;
	q -> next -> prior = p;
	free(q);
```

### 循环链表

尾结点的`next`指向头结点，循环双链表的头结点的`prior`指向尾结点
空表的头结点的`next`和`prior`都指向自己

### 静态链表

```cpp
#define MaxSize 50

typedef struct {
	ElemType data;
	int next;		//游标，下一个元素的数组下标
} SLinkList[MaxSize];
```

用数组表示线性表，最后一个元素`next == -1`

### 顺序表和链表的比较

- 读写（存取）方式

顺序表既可以顺序读写，也可以随机读写
链表只能顺序读写

- 逻辑结构与物理结构

顺序存储中，逻辑上相邻的元素，物理位置也相邻
链式存储中不一定相邻

- 查找，插入和删除

按值查找
	顺序表无序时O(n)，有序时可以做到O(logn)
	链表O(n)

按序号查找 
	顺序表O(1)
	链表O(n)

- 空间分配

顺序存储在静态分配时需要预先分配足够大的空间，动态分配时空间可以扩充，但也造成效率降低；优点是存储密度大

链式存储的优点是灵活，缺点是每个结点都有指针，存储密度低

## 栈

```cpp
InitStack(&S);
StackEmpty(S);
Push(&S, x);
Pop(&S, &x);
GetTop(S, &x);
DestroyStack(&S);
```

> 出栈序列问题 \
\
Catalan数：n个不同元素出栈的排列可能性为\
$$\frac{1}{n + 1}C^n_{2n}$$ \
\
因为仅有出栈/入栈二元操作，考虑用二叉树表示：\
连续入栈的元素向左，当前元素出栈后入栈的元素向右\
出栈序列就是二叉树的**中序遍历**\
\
此时，最先出栈的元素在树的最左端，最后出栈的在最右端，可以用这一性质做给定某几个出栈顺序的题目\
用序列反推树：第一个元素作为左端，若下一个元素入栈遵从入栈顺序，说明是连续入栈，当前元素是其左子；否则，说明当前元素出栈后下一个元素才入栈，当前元素是其右子；整个过程遵从递归逻辑
{: .prompt-tip}

### 顺序栈

```cpp
#define MaxSize 50;

typedef struct {
	ElemType data[MaxSize];
	int top;				//标记栈顶
} SqStack;

/* 初始化 */
void InitStack(SqStack &S) {
	S.top = -1;
}

/* 判空 */
bool StackEmpty(SqStack S) {
	return S.top == -1;
}

bool Push(SqStack &S, ElemType x) {
	if (S.top == MaxSize - 1)
		return false;

	top ++;
	S.data[S.top] = x;
	return true;
}

bool Pop(SqStack &S, ElemType &x) {
	if (StackEmpty(S))
		return false;

	x = S.data[top];
	top --;
	return true;
}

bool GetTop(SqStack S, ElemType &x) {
	if (S.top == 1) 
		return false;

	x = S.data[S.top];
	return true;
}
```

如果初始`top`为0，表示指向下一个位置，相应代码发生变化

#### 共享栈

两个顺序栈共享一个一维数组，栈底分别设置在两端；

### 链栈

```cpp
typedef struct LinkNode {
	ElemType data;
	struct LinkNode *next;
} LiStack;
```

可以用只在表头插入和删除的单链表实现；

## 队列

```cpp
InitDeQueue(&Q);
QueueEmpty(Q);
EnQueue(&Q);
DeQueue(&Q, &x);
GetHead(Q, &x);
```

### 队列的顺序存储，循环队列

```cpp
#define MaxSize 50

typedef struct {
	ElemType data[MaxSize];
	int front rear;				// 王道书中rear指向队尾的下一个位置；
} SqQueue;

void InitQueue(SqQueue &Q) {
	Q.front = 0;
	Q.rear = 0;
}

bool isEmpty(SqQueue Q) {
	return Q.front == Q.rear;
}

bool EnQueue(SqQueue &Q, ElemType x) {
	if ((Q.rear + 1) % MaxSize == Q.front) 		// 队满条件
		return false;

	Q.data[Q.rear] = x;
	Q.rear = (Q.rear + 1) % MaxSize;

	return true;
}

bool DeQueue(SqQueue &Q, ElemType &x) {
	if (isEmpty(Q)) 
		return false;

	x = Q.data[front];
	Q.front = (Q.front + 1) % MaxSize;

	return true;
}
```

这种做法会使得实际可用空间少一个，因为判满的条件是`(Q.rear + 1) % MaxSize == Q.front`，即`rear`在`front`前一格，而`rear`是下一个队尾应该放入的位置

其余做法：引入`size`，或引入`tag`记录上次操作是删除还是加入

> 选择题考察：front和rear的关系(判空，判满，判断长度等等)
{: .prompt-tip}

### 队列的链式存储

实际上是一个同时有表头指针和表尾指针的单链表，通常使用带头结点的单链表

```cpp
typedef struct LinkNode {
	ElemType data;
	struct LinkNode *next;
} LinkNode;

typedef struct {
	LinkNode *front, *rear;
} LinkQueue;

void InitQueue(LinkQueue &Q) {
	Q.front = (LinkNode *) malloc(sizeof(LinkNode));
	Q.rear = Q.front;									// 初始时，头尾都为头结点
	Q.front -> next = NULL;
}

bool isEmpty(LinkQueue Q) {
	return Q.front == Q.rear;
}

void EnQueue(LinkQueue &Q, ElemType x) {
	LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
	s -> data = x;
	s -> next = NULL;
	Q.rear -> next = s;
	Q.rear = s;
}

bool DeQueue(LinkQueue &Q, ElemType &x) {
	if (isEmpty(Q))
		return false;

	LinkNode *p = Q.front -> next;
	x = p -> data;
	Q.front -> next = p -> next;
	if (Q.rear == p) 
		Q.rear = Q.front;
	free(p);

	return true;
}
```

### 双端队列

双端队列出队序列分析

## 栈和队列的应用

### 栈在括号匹配中的应用

### 栈在表达式求值中的应用

#### 中缀转后缀

#### 后缀求值

#### 中缀转前缀

#### 前缀求值

#### 前缀求值

### 栈在递归中的应用

### 队列在层次遍历中的应用

### 队列在计算机系统中的应用
